[
["rawR.html", "5 原生的R 5.1 一句话Tips 5.2 大数据的存取 5.3 平行计算 5.4 类和方法 5.5 打印到文件 5.6 apply函数族 5.7 Linux中的R 5.8 如何完美复制项目的结果", " 5 原生的R 5.1 一句话Tips do.call(str_fun, args, quote, envir)函数感觉很好用, 第一个参数是字符串函数名，第二个参数是一个list, 它里面元素的名字就是你调用的函数的参数的名字。在某种程度上，它可以替代eval(parse(text = str))的作用。 从本地安装一个源码包： install.packages(&#39;E:\\\\17_HuaDong\\\\NEDatabase\\\\MyRef.Attachments\\\\RForEconometrics/phtt_3.1.2.tar.gz&#39;,type = &#39;source&#39;,repos = NULL) suppressMessages()可以抑制代码抛出的信息等。 +(3,1)与3+1的作用是一样的。这可以推广到其他中缀函数，如%*%等。 写函数时，可以使用...参数，为捕获这个(可能是多个)参数的值，可以用list(...)这个办法。 只显示3位小数： round(0.123456,3) ## [1] 0.123 属性赋值： y &lt;- c(1,2,5,8) attr(y,&#39;my_attribute&#39;) &lt;- &#39;This is a vector&#39; attr(y,&#39;my_attribute&#39;) ## [1] &quot;This is a vector&quot; remove.packages('dplyr')，卸载已安装的包。 system或shell运行Shell命令。 更新所有的包update.packages(checkBuilt=TRUE, ask=FALSE) pkgsearch包的ps函数提供CRAN的关键词搜寻。 detach(package:dplyr)可以去掉加载的包。 foreach包提供循环的平行计算 在jupyter里面安装R，只需在anaconda里面的命令行中（anaconda prompt）输入， conda install -c r r-essentials 工作目录下所有文件名dir() file.copy, file.create, file.remove, file.rename, dir.creat, file.exists, file.info file.rename批量修改文件名 fr = paste(&#39;./加工贸易HS/2016/&#39;,dir(&#39;./加工贸易HS/2016&#39;),sep = &#39;&#39;) to = paste(&#39;./加工贸易HS/2016/hp&#39;,dir(&#39;./加工贸易HS/2016&#39;),sep = &#39;&#39;) file.rename(from = fr,to = to) down.file只要给出第一个参数：网址（包括ftp的）和第二个参数，下载的文件要保存的文件名，就可以直接在网上下载文件。如果中国乱码，记得使用fileEncoding = ’UTF-8’来修正。 getAnywhere(predict.Arima)查看源代码 .rs.restartR()重启一个新的R会话 如何安装已经过期的包？ 点这里找到过期的包，然后下载下来。 用这个命令安装本地的包：install.packages('D:/MSBVAR_0.9-3.tar.gz',repos = NULL, type = 'source') 5.2 大数据的存取 对于大的数据，载入内存运算往往给内存造成很大负担，16G内存的电脑，超过500M，就应该考虑将数据存到硬盘上，然后利用SOAR包进行调用。通常可如下调用 library(SOAR) Store(&quot;some_data&quot;) 这会有如下动作： 在工作目录下创建一个子目录.R_Cache。这个目录是隐藏的，可以通过在RStudio右下角Plane中的Files标签中通过勾选显示隐藏而看到。 对象some_data以.Rdata的形式存储在该子目录中； 对象some_data在全局环境中被删掉； 此时，在该工作目录下，可以像调用全局环境中的变量一样调用some_data。同时还可以用Remove来去掉该变量，用Ls()来查看路径中有哪些变量。 5.3 平行计算 5.3.1 循环中的平行运算 平行计算中，光使用foreach包是不够的，还需要注册一个平行背景注册，否则foreach包在运算完以后会返回警告： # Warning message: # # executing %dopar% sequentially: no parallel backend registered 平行计算一般的工作流如下： library(doParallel) cl &lt;- parallel::makeCluster(2) doParallel::registerDoParallel(cl) foreach(i=1:3, .pacakages = &#39;tidyverse&#39;) %dopar% sqrt(i) parallel::stopCluster(cl) 要注意，平行计算中，在foreach后的语句中，相当于在每个进程中，重启了一个新环境。因此，如果你要用到foreach外面的变量，则需要把变量、包等都传进去。同时，这些变量如果是向量或者list则不需要特别地指定迭代变量是哪个，程序会自动将它们处理成迭代变量。如果这些变量的长度不一，则迭代时以最少长度的变量为准。一个简单的例子(VARrf::IRFrf_gen)如下： # 传进去了5个变量,nhist, itevar,pmax,s, shockvar，这些变量的长度都是一样的。 picdata &lt;- foreach::foreach(i = 1:nhist,itevar = itevar, pmax = pmax_para,s = s, shockvar = shockvar, .packages = &#39;tidyverse&#39;) %dopar% { devtools::load_all() IRFrf(data = itevar, pmax = pmax, s = s, shockvar = shockvar,histime = i) } 5.3.2 apply族的平行版本 library(parallel) cl &lt;- makeCluster(6) # Windows并行时，每个进程中是没有变量的，所以要把变量导入到每个进程中去 # clusterExport(cl, varlist) # 并行运算 # parLapply(cl, c(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;), FUN) stopCluster(cl) 5.4 类和方法 5.4.1 S3类 # 查看属于一个泛型函数的所有方法： methods(&#39;mean&#39;) ## [1] mean.Date mean.default mean.difftime mean.POSIXct mean.POSIXlt ## [6] mean.quosure* ## see &#39;?methods&#39; for accessing help and source code # 反过来，查看一个类，都有何关联的泛型函数 methods(class = &#39;ts&#39;) ## [1] [ [&lt;- aggregate as.data.frame cbind ## [6] coerce cycle diff diffinv initialize ## [11] kernapply lines Math Math2 monthplot ## [16] na.omit Ops plot print show ## [21] slotsFromS3 t time window window&lt;- ## see &#39;?methods&#39; for accessing help and source code 创建一个类，很多时候只需在最后返回一个这样的，就可以了， class(foo) &lt;- &#39;myclass&#39; 然后为这个类创建一个泛型函数，只需要两步： # 创建一个类 a &lt;- list() class(a) &lt;- &#39;a&#39; # 第一步：增加一个新的泛型函数。记住，没有搭配该泛型函数的方法，泛型函数是没有用的。 f &lt;- function(x) UseMethod(&#39;f&#39;) # 第二步，为此泛型函数添加方法。关键在于命名规则，属于该泛型函数的方法一定具有类似f.a格式的命名。 # f是泛型函数, a是类,它们用点连起来。 f.a &lt;- function(x) &#39;class a&#39; mean.a &lt;- function(x) &#39;a&#39; # 为已有的泛型函数增加方法 5.5 打印到文件 sink函数：在代码开始前加一行：sink(“output.txt”)，就会自动把结果全部输出到工作文件夹下的output.txt文本文档。这时在R控制台的输出窗口中是看不到输出结果的。代码结束时用sink()切换回来。 示例： sink(&quot;a.txt&quot;) x&lt;-rnorm(100,0,1) mean(x) sink() cat函数：cat('abc','OK!',file = 'a.txt',sep = '\\n',append = T) stargazer函数： stargazer(fit1, fit2, title = &quot;results&quot;, align = F, type = &quot;text&quot;, no.space = TRUE, out = &quot;fit.html&quot;) 5.6 apply函数族 lapply(vector,fun)，可以将函数作用于向量vector的每一个元素上，然后返回一个list。 sapply(vector,fun)的好处在于不是返回一个list，而是返回一个向量或者矩阵。如果fun返回的是一个元素，那么sapply就返回一个向量，如果fun返回的是一个向量，则sapply按列将结果拼接成一个矩阵。 sapply(1:10, function(i) i^2) ## [1] 1 4 9 16 25 36 49 64 81 100 sapply(1:10, function(i) c(i^2,i)) ## [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] ## [1,] 1 4 9 16 25 36 49 64 81 100 ## [2,] 1 2 3 4 5 6 7 8 9 10 apply是我用得最熟的，它是将函数应用到矩阵或数组的行或列上。 mapply是lapply或sapply的多元版本，即它可以同时输入多个向量，如 mapply(function(x,y,z) x*y + y*z + x*z, x = c(1,2,3),y = c(1,2,3), z = c(-1,-2,-3)) ## [1] -1 -4 -9 5.7 Linux中的R 很多时候，对服务器我们没有权限，因此我们只能下载包的源码，然后安装。工作流如下： - 在自己有权限的目录下新建一个目录，比如/data/stage/chenpu/RLib作为包的安装目录，命令为 mkdir /data/stage/chenpu/RLib 将包的源码下载下来，然后命令行安装 R CMD INSTALL /.../mypackage.tar.gz --library=/data/stage/chenpu/RLib 在R跑程序，加载的时候，要注意lib.loc参数， library(zoo, lib.loc = &#39;/data/stage/chenpu/RLib&#39;) 或者修改启动文件.Rprofile，这就不会每次启动R都要重新设置了。 5.7.1 如何修改.Rprofile？ 进入R以后， R.home() # 确定R安装在了哪里 file.edit(file.path(&#39;~&#39;,&#39;.Rprofile&#39;)) # 编辑Rprofile # 此时进入vi界面， 在插入模式下，键入 .libPaths(&#39;/data/stage/chenpu/RLib&#39;) # 再按Esc退出插入模式进入命令行模式，输入`:wq`保存退出。 5.7.2 Ubuntu下安装最新的R 在/etc/apt/sources.list文件中增加软件的镜像源，deb https://cloud.r-project.org/bin/linux/ubuntu bionic-cran40/，也就是增加这样一行。注意后面这个bionic-cran40，它对应着Ubuntu系统下R4.0版本。 更新源： sudo apt-get update 更新的时候往往会报错，说是没有公钥。此时用这个命令增加公钥： sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 6AF0E1940624A220 注意，此处6AF0E1940624A220是你更新源时报错提示的key。 3. 安装： sudo apt-get install r-base 5.8 如何完美复制项目的结果 在写一个项目时，往往对应着当时你调用的各种R包的版本。一年以后，许多包已经更新，可能你当时的代码结果已经无法复制。我们需要管理不同版本的R包。 renv包就是干这个的。工作流如下： renv::init()初始化这个项目，会生产对应该项目的包库文件目录。此时安装包，都是在这个私有库下进行，不影响全局的包库。 renv::snapshot()记下此时包的各个版本。 renv::restore()恢复上一个快照时包库的状态。 "]
]
