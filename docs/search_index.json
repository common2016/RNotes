[["index.html", "R语言笔记 序", " R语言笔记 云腾足下 2020年9月 序 不知道说啥，还是留首诗吧。 赵客缦胡缨，吴钩霜雪明。 银鞍照白马，飒沓如流星。 十步杀一人，千里不留行。 事了拂衣去，深藏功与名。 闲过信陵饮，脱剑膝前横。 将炙啖朱亥，持觞劝侯嬴。 三杯吐然诺，五岳倒为轻。 眼花耳热后，意气素霓生。 救赵挥金锤，邯郸先震惊。 千秋二壮士，烜赫大梁城。 纵死侠骨香，不惭世上英。 谁能书阁下，白首太玄经。 "],["PanelData.html", "1 面板数据 1.1 一句话Tips 1.2 plm包 1.3 动态面板阈值估计：R语言中有一个包dtp，其估计函数为：", " 1 面板数据 1.1 一句话Tips PSTR:面板平滑转移模型。 MSCMT:多个结果变量的合成控制方法的包。 检查面板数据是否平衡：使用table(PanelData[,1:2])或者is.banance。 phtt包，交互效应的面板模型，用的Bai (2009)的估计方法。It offers the possibility of analyzing panel data with large dimensions n and T and can be considered when the unobserved heterogeneity effects are time-varying. 1.2 plm包 包中的vcovG函数可以计算聚类标准误。一般这么用: summary(plm, vcov = vcovG(plm, cluster = &#39;group&#39;, inner = &#39;cluster&#39;)) 包中的fixef函数可以返回个体截距项(type = level)。 update(object, formula)函数可以更新公式重新估计。 1.3 动态面板阈值估计：R语言中有一个包dtp，其估计函数为： data(Mena) reg&lt;-dtp(GDPPC ~ FDI+OPEN|INF|INF,Mena,index=c(&quot;pays&quot;,&quot;ann&quot;),4,2,0.95,0.8,1,graph = TRUE) summary(reg) 注意： 第一根|前的变量是不依赖区制的变量，中间由|夹住的变量是阈值变量，最后一个|后面的变量是依赖区制的变量（好遗憾，貌似只允许一个这样的变量）。 initnum参数指的是模型中的内生变量。在动态面板中，一般是因变量的滞后值，因此在数据框中滞后因变量，然后选好该滞后因变量所在列的数字即可。注意，这个数字是在剔除了id和year标识之后的列的序号。 数据上千以后，估计过程有点慢，耐心等待。 输出中包含一个gamma参数，我揣摩是截距项。 "],["TS.html", "2 普通回归和时间序列序列 2.1 一句话Tips 2.2 GMM估计 2.3 季节调整", " 2 普通回归和时间序列序列 2.1 一句话Tips gdpc计算广义动态主成分。 POET::POETKhat提供了计算Bai and NG (2002)因子数目的函数。 confint函数返回系数的置信区间 bssm拟合非线性卡尔曼滤波的包。pomp，KFAS也是。pomp好像接口更简单些，第四节有一个非线性的例子。 NlinTS一个利用神经网络的格兰杰因果非线性检验。 slider: 在任何R数据类型上提供类型稳定的滚动窗口函数，并支持累积窗口和扩展窗口。 testcorr: 提供计算单变量时间序列中自相关显著性、双变量时间序列中互相关显著性、多变量序列中皮尔逊相关显著性和单变量序列i.i.d.特性的测试统计量的功能。 apt一个阈值协整包。 fDMA动态平均模型。卡尔曼滤波的贝叶斯模型平均。 MuMIn利用信息准则进行模型平均的包。 MSBVAR提供了贝叶斯框架下的马尔科夫转移VAR。MSwM是一个单方程（非单变量）的马尔科夫转移模型估计。 因子变虚拟变量：model.matrix可以生成回归所需要的矩阵，可以把因子变量变成虚拟变量。 mfGARCH包估计混频GARCH。 TED::ur.za.fast和urca::ur.za未知断点的单位根检验。 mFilter包有各种经济和金融常用的滤波，如HP，BK等滤波（好像没有更新了，官网包的镜像没有找到）。但是可以使用FRAPO包的trdhp函数来计算HP滤波 。 svars是一个数据驱动的结构VAR包。vars是一个VAR各种估计和诊断的标准包。tsDyn也有线性VAR和VECM的估计，其中它还允许包含外生变量。 lmtest有grangertest()做双变量格兰杰因果检验。MTS::GrangerTest(regdata[,-c(1,2)],2,locInput = 1)也可以，而且可以做多个变量是不是某个变量的格兰杰原因。locInput表示因变量是第几列。 stats4包提供了函数mle可以进行极大似然估计，还可以固定部分参数，优化其他参数，这其实是集中似然的思想。关键是它还返回方差协方差矩阵。语法如下， mle(minuslogl, start = formals(minuslogl), method = &quot;BFGS&quot;, fixed = list(), nobs, ...) # 注意它的初值是一个list dynlm::dynlm包一个比lm更强大线性回归结构，优点有三： 可以使用差分、滞后等表述，如d(y)~L(y,2)，可以直接添加趋势项trend(y)将使用$(1:n)/Freq$作为回归元。 可以进行工具变量估计。 但要注意，他的数据不是数据框，而是一个ts对象。 nardl估计非线性协整分布滞后模型。 rugarch：单变量garch建模。一个比forcast更好用的时序建模包。可以用show函数来返回一个丰富的结果，包括一些检验结果。 rmgarch：多变量garch建模。包括dcc,adcc,gdcc等。 stats包中的ARMAtoMA函数可以计算AR变成MA。vars包的Phi返回VAR的移动平均系数。 vars包里面的Phi函数可以把VAR变成VMA。使用summary函数来摘要var的估计结果，会给粗特征根，残差相关矩阵等。 tsDyn包的VECM函数比较好用，可以包括外生变量，可以选择OLS或Joson方法。这个包也是可以估计线性VAR的，主要是他的lineVar函数。egcm包是恩格尔格兰杰协整检验，这个检验在urca包里业可行。 TSA::periodogram可以做谱分解。 bvarsv时变参数var建模 nls非线性最小二乘法函数 highfrequance里面有不少意思的函数，包括HAR。 ## 回归中关于公式的理解和构造 # 构造公式, 只要包含波浪线就意味着这是一个公式。 F1 &lt;- dist ~ speed - 1 # 获得公式中所有的变量 mf1 &lt;- model.frame(F1,data = cars) # 抽取因变量 model.response(mf1) # 抽取自变量 model.matrix(F1, data = cars) 公式的高级应用还有一个包Formula，其说明文件很到位。主要阐述了|的使用方式。 2.2 GMM估计 \\[ i _t =\\beta_0 + \\beta_1pi_t + \\beta_2GDP_t + \\beta_3hp_t + \\beta_4i_{t-1} + \\varepsilon_t \\] 因包含因变量的滞后项从而有内生性，欲使用\\(i_{t-2},i_{t-3},i_{t-4}\\)作为工具变量，从而做一个GMM估计，亦即整个方程的矩条件为， \\[\\begin{align} E(pi_t\\varepsilon_t) = 0\\\\ E(GDP_t\\varepsilon_t) = 0\\\\ E(hp_t\\varepsilon_t) = 0\\\\ E(i_{t-2}\\varepsilon_t) = 0\\\\ E(i_{t-3}\\varepsilon_t) = 0\\\\ E(i_{t-4}\\varepsilon_t) = 0 \\end{align}\\] 利用这些矩条件的GMM估计在gmm包中的写法为， gmmrlt &lt;- gmm(g = it ~ pi + gdp + hp + it1, x = ~ pi + gdp + hp + it2 + it3 + it4,data = dwg0) summary(gmmrlt) 其中g可直接写成公式，x即为工具变量集。 2.3 季节调整 2.3.1 R中有x12包可以做季节处理 注意： 要先下载美国统计局的x12程序包，并在调用函数时，记得写上所以存储的路径。 仅可处理R中内置的时间序列对象ts。 示例代码： library(x12) data(AirPassengers) x12out &lt;- x12work(AirPassengers, x12path = &#39;C:\\\\ado\\\\plus\\\\WinX12\\\\x12a\\\\x12a.exe&#39;,keep_x12out = FALSE) x12out$d11 #此即为调整后的时间序列 其中，keep_x12out参数表示是否要保留计算后的文件。 2.3.2 seasonal包有x13处理，更加便捷 library(seasonal) m &lt;- seas(AirPassengers) # x13 处理, AirPassengers是一个ts对象 final(m) # 最终调整序列 plot(m) # 绘制调整和未调整序列 "],["DataProcess.html", "3 数据处理 3.1 一句话Tips 3.2 RJSDMX包下载世界各大数据库数据 3.3 前向、后向、线性和样条插值", " 3 数据处理 3.1 一句话Tips 因子操作 # 使用字符串有两个缺陷：第一，不在因子水平范围内的不会转化成NA # 第二，仅按字母排序。 # 因此，通过设定因子水平，可以解决上述两个问题。注意水平和字符串是一样的， # 只是相当于设定了范围和排序。 factor(c(&#39;Dec&#39;,&#39;Apr&#39;,&#39;Jam&#39;,&#39;Mar&#39;), levels = (&#39;Jan&#39;,&#39;Feb&#39;,&#39;Mar&#39;,&#39;Apr&#39;,&#39;May&#39;)) # 因子重编码, 把1改成unmarried等 farcats::fct_recode(rawdata$marrige, &#39;unmarried&#39;=&#39;1&#39;,&#39;married&#39;=&#39;2&#39;,&#39;cohabitation&#39;=&#39;3&#39;,&#39;divore&#39;=&#39;4&#39;,&#39;wid&#39;=&#39;5&#39;) dbplyr可以连接到几乎任何数据库。 wbstats下载世界银行数据，很牛逼。Stata里面的wbopendata包更牛逼。 stationaRy:一个从NOAA上下载气象数据，如气温，风向等的包。该包就三个函数，一个用来得到站点id，一个用这个id下载数据，还有一个是如果你想得到其他额外的气象数据时可能有用。 当你发现你用save命令保存一个数据长达数分钟时，建议你迅速调用qs包，可能一分钟不到就帮你快速读入和保存了。但这个包一次只能保存一个变量。 tor: 提供允许用户同时导入多个文件的功能. 读入excel中的sheet名：openxlsx::getSheetNames(file) XLConect处理excel最强大的包。但需要JRE（java run enviornment）。 # 可以不改变原有数据，然后把一个数据框精准地写入某个地方 writeWorksheetToFile(&quot;XLConnectExample2.xlsx&quot;, data = ChickWeight, sheet = &quot;chickSheet&quot;, startRow = 3, startCol = 4,header = FALSE, clearSheets = FALSE) 使用as.Date来生成日期，必须带有年月日三个要素，使用format来输出日期格式，此时可以只输出年和月。如as.Date('2010/05/01') %&gt;% format(.,format = '%Y%m') seq.Date()生成日期序列，包括日、星期、月、年。 readstata13包可以读入更高版本的stata数据格式。 zoo::rollapply(x, 30, mean)就是30天的移动平均求值。 select是一个很牛逼的函数 select(regdata,id, year) # 选择regdata数据框的id和year两列 select(regdata,starts_with(&#39;abc&#39;)) # 匹配以&#39;abc&#39;开头的列 select(regdata,ends_with(&#39;abc&#39;)) # 匹配以&#39;abc&#39;结尾的列 select(regdata,contains(&#39;abc&#39;)) # 匹配包含&#39;abc&#39;的列 select(regdata,matches(&#39;abc&#39;)) # 正则表达匹配 select(regdata,num_range(&#39;x&#39;,1:3)) # 匹配x1, x2,x3的列 R语言给数组各维数命名 # Create two vectors of different lengths. vector1 &lt;- c(5,9,3) vector2 &lt;- c(10,11,12,13,14,15) column.names &lt;- c(&quot;COL1&quot;,&quot;COL2&quot;,&quot;COL3&quot;) row.names &lt;- c(&quot;ROW1&quot;,&quot;ROW2&quot;,&quot;ROW3&quot;) matrix.names &lt;- c(&quot;Matrix1&quot;,&quot;Matrix2&quot;) # Take these vectors as input to the array. result &lt;- array(c(vector1,vector2),dim = c(3,3,2),dimnames = list(row.names,column.names, matrix.names)) print(result) pdftools包的函数可以读PDF文件： pdf_info(pdf, opw = &quot;&quot;, upw = &quot;&quot;) pdf_text(pdf, opw = &quot;&quot;, upw = &quot;&quot;) pdf_data(pdf, opw = &quot;&quot;, upw = &quot;&quot;) pdf_fonts(pdf, opw = &quot;&quot;, upw = &quot;&quot;) pdf_attachments(pdf, opw = &quot;&quot;, upw = &quot;&quot;) pdf_toc(pdf, opw = &quot;&quot;, upw = &quot;&quot;) pdf_pagesize(pdf, opw = &quot;&quot;, upw = &quot;&quot;) 同时，利用qpdf包的pdf_subset,pdf_combine,pdf_split可以提取PDF的部分内容，合并PDF文件，把每一页分成一个PDF文件。 3.2 RJSDMX包下载世界各大数据库数据 一般工作流： library(RJSDMX) # 查看有哪些库可以用 getProviders() # 库中有哪些子库可以用 getFlows(&#39;WITS&#39;) # 该子库调取数据需要哪几个字段 getDimensions(&#39;WITS&#39;,&#39;WBG_WITS,DF_WITS_TradeStats_Tariff,1.0&#39;) # 查看这个指标有几个选项 getCodes(&#39;WITS&#39;,&#39;WBG_WITS,DF_WITS_TradeStats_Tariff,1.0&#39;,&#39;INDICATOR&#39;) # 查好了就可以下载 ans &lt;- getTimeSeries(&#39;WITS&#39;, &#39;DF_WITS_TradeStats_Tariff/A.CHN.WLD.01-05_Animal.MFN-WGHTD-AVRG&#39;) # 你也可以调用图形窗口查阅命令 sdmxHelp() IMF2里面的IFS数据库里面有很多季度的宏观数据，如GDP，固定资本形成等 3.3 前向、后向、线性和样条插值 zoo包 zoo::na.locf缺省设置可以前向插，即缺失值等于前面的值。当将该函数的fromLast参数设为真时，即为后向插。 zoo:na.approx可以线性插值但不能外推；na.spline可以样条插值； imputeTS包,imputeTS::na.locf也可以，不过它只能对数值。它也有后向插值选项。 3.3.1 signal包 它有一个插值函数interp1函数，比较好用： interp1(x, y, xi, method = c(&quot;linear&quot;, &quot;nearest&quot;, &quot;pchip&quot;, &quot;cubic&quot;, &quot;spline&quot;), extrap = NA, ...) 它的参数说明如下 x,y：vectors giving the coordinates of the points to be interpolated. x is assumed to be strictly monotonic. xi：points at which to interpolate. method ： one of “linear”, “nearest”, “pchip”, “cubic”, “spline”. ‘nearest’: return nearest neighbour ‘linear’: linear interpolation from nearest neighbours ‘pchip’: piecewise cubic hermite interpolating polynomial ‘cubic’: cubic interpolation from four nearest neighbours ‘spline’: cubic spline interpolation–smooth first and second derivatives throughout the curve. for method=‘spline’, additional arguments passed to splinefun. Details extrap： if TRUE or ‘extrap’, then extrapolate values beyond the endpoints. If extrap is a number, replace values beyond the endpoints with that number (defaults to NA). "],["统计.html", "4 统计 4.1 一句话Tips 4.2 MCMC算法", " 4 统计 4.1 一句话Tips cmna::mcint可以进行蒙特卡洛积分。 数值积分：pracma::integral 多元正态分布随机抽样：SimDesign::rmvnorm，还有mvnfast。mvtnorm包是多变量正态分布的包，很全。 KSgeneral包执行KS检验，比较一个分布是否来自某个理论分布。stats包的ks.test和dgof包的ks.test也可以,并且可以比较双样本是否来自同一个分布。 choose(n,k)：组合公式，n个里面选k个，有多少种组合方式。utils::combn(n,k)也可以。 e1071::permutations实现排列。 qrandom: 利用量子波动产生真随机数. 主成分分析可以调用psych包两个步骤实现： # 画个图选特征值数目： # 1. 特征值在1以上的才行； 2. 特征值大于模拟的平均特征才可行； 3. 碎石图 library(psych) fa.parallel(regdata, fa = &#39;pc&#39;) # 计算2个主成分。如果想要主成分载荷更有经济意义，注意设置旋转参数 principal(regdata,nfactors = 2,rotate = &#39;none&#39;) 4.2 MCMC算法 4.2.1 吉布斯抽样原理 如果联合分布不好求，但条件分布好求，可以用这个算法。 4.2.2 一些共轭先验分布的结论 理解这些结论，对于后续使用吉布斯抽样、MH算法非常有用。 结论1 若\\(x_1,\\cdots,x_n\\)是从均值为\\(\\mu\\)(未知)，方差为\\(\\sigma^2\\)(已知且为正)中正态分布中所抽取的一个随机样本，同时假定\\(\\mu\\sim \\mathcal{N}(\\mu_0,\\sigma_0^2)\\)，则给定数据和先验分布，\\(\\mu\\)的后验分布也是一个正态分布，其后验均值和方差为， \\[\\mu_* = \\frac{\\sigma^2\\mu_0+n\\sigma_0^2\\overline x}{\\sigma^2+n\\sigma_0^2},\\hspace{2em}\\sigma_*=\\frac{\\sigma^2\\sigma^2_0}{\\sigma^2+n\\sigma^2_0},\\;\\;\\;\\text{其中},\\overline x= \\sum_i^n x_i/n\\] 推广到多变量，则可以写为， \\[{\\mu}_*=\\Sigma_*(\\Sigma_0^{-1}{\\mu}_0+\\Sigma^{-1}\\overline{\\bf{x}}), \\hspace{2em}\\Sigma_*^{-1} = \\Sigma_0^{-1}+n\\Sigma^{-1}\\] 结论2 若\\(e_1,\\cdots,e_n\\)是从均值为0，方差为\\(\\sigma^2\\)的正态分布中抽取的随机样本，同时假定\\(\\sigma^2\\)的先验分布是自由度为\\(\\nu\\)的逆\\(\\chi^2\\)分布，即\\(\\frac{\\nu\\lambda}{\\sigma^2}\\sim \\chi^2_\\nu,\\lambda&gt;0\\)，则\\(\\sigma^2\\)的后验分布也是逆\\(\\chi^2\\)分布，自由度为\\(\\nu+n\\)， \\[\\frac{\\nu\\lambda+\\sum_i^ne_i^2}{\\sigma^2}\\sim \\chi^2_{\\nu+n}\\] 4.2.3 一个吉布斯抽样的典型案例 一个带自相关的回归模型可以写为， \\[\\begin{align} y_t&amp;=\\beta_0+\\beta_1x_{1t}+\\cdots+\\beta_kx_{kt}+z_t\\\\ z_t&amp;=\\phi z_{t-1}+e_t \\end{align}\\] 该模型需要估计的参数有三个，即\\(\\theta = (\\beta&#39;,\\phi,\\sigma^2)\\)。该参数的联合分布并不好求，但是条件分布则好求得多。 4.2.4 Metropolis 和 M-H算法 如果后验分布除了那个归一化的常数不知道，但分子是知道的，那可以用这个算法。这个场景是不是在贝叶斯估计中很熟悉？ MCMCpack::MCMCmetrop1R中有个例子提供了Metropolis算法，感觉还是很清晰。里面提到的’The proposal distribution’其实就是跳跃分布，即给定上一次抽样的参数，从这个跳跃分布中抽下一个参数。 4.2.5 一些带贝叶斯估计的R包使用报告 MTS::BVAR：这个包可以在一个一般的先验设定上估计VAR，先验可以是乏信息先验，也可以是明尼苏达先验，但问题是该包仅返回估计系数的均值和标准误，不返回抽样。 bvartools：在很大程度上可以定制BVAR的mcmc抽样，见它的一个优秀的引言。我用这个,自己写了乏信息先验的BVAR估计包。下次我再把明尼苏达先验添进去。 MCMCpack::MCMCregress:单方程的贝叶斯估计，它提供了\\(\\beta\\)是多元正态先验，方程误差项的方差协方差是逆伽玛的先验估计。 bayesm::runireg：单方程的贝叶斯估计，它提供了\\(\\beta\\)是多元正态先验，方程误差项的方差协方差是卡方分布的先验估计。 "],["rawR.html", "5 原生的R 5.1 一句话Tips 5.2 大数据的存取 5.3 RStudio-server管理 5.4 平行计算 5.5 类和方法 5.6 打印到文件 5.7 apply函数族 5.8 Linux中的R 5.9 如何完美复制项目的结果", " 5 原生的R 5.1 一句话Tips object.size()可以查看某个对象占了多少内存。 do.call(str_fun, args, quote, envir)函数感觉很好用, 第一个参数是字符串函数名，第二个参数是一个list, 它里面元素的名字就是你调用的函数的参数的名字。在某种程度上，它可以替代eval(parse(text = str))的作用。 从本地安装一个源码包： install.packages(&#39;E:\\\\17_HuaDong\\\\NEDatabase\\\\MyRef.Attachments\\\\RForEconometrics/phtt_3.1.2.tar.gz&#39;,type = &#39;source&#39;,repos = NULL) suppressMessages()可以抑制代码抛出的信息等。 +(3,1)与3+1的作用是一样的。这可以推广到其他中缀函数，如%*%等。 写函数时，可以使用...参数，为捕获这个(可能是多个)参数的值，可以用list(...)这个办法。 只显示3位小数： round(0.123456,3) ## [1] 0.123 属性赋值： y &lt;- c(1,2,5,8) attr(y,&#39;my_attribute&#39;) &lt;- &#39;This is a vector&#39; attr(y,&#39;my_attribute&#39;) ## [1] &quot;This is a vector&quot; remove.packages('dplyr')，卸载已安装的包。 system或shell运行Shell命令。 更新所有的包update.packages(checkBuilt=TRUE, ask=FALSE) pkgsearch包的ps函数提供CRAN的关键词搜寻。 detach(package:dplyr)可以去掉加载的包。 foreach包提供循环的平行计算 在jupyter里面安装R，只需在anaconda里面的命令行中（anaconda prompt）输入， conda install -c r r-essentials 工作目录下所有文件名dir() file.copy, file.create, file.remove, file.rename, dir.creat, file.exists, file.info file.rename批量修改文件名 fr = paste(&#39;./加工贸易HS/2016/&#39;,dir(&#39;./加工贸易HS/2016&#39;),sep = &#39;&#39;) to = paste(&#39;./加工贸易HS/2016/hp&#39;,dir(&#39;./加工贸易HS/2016&#39;),sep = &#39;&#39;) file.rename(from = fr,to = to) down.file只要给出第一个参数：网址（包括ftp的）和第二个参数，下载的文件要保存的文件名，就可以直接在网上下载文件。如果中国乱码，记得使用fileEncoding = ’UTF-8’来修正。 getAnywhere(predict.Arima)查看源代码 .rs.restartR()重启一个新的R会话 如何安装已经过期的包？ 点这里找到过期的包，然后下载下来。 用这个命令安装本地的包：install.packages('D:/MSBVAR_0.9-3.tar.gz',repos = NULL, type = 'source') 5.2 大数据的存取 对于大的数据，载入内存运算往往给内存造成很大负担，16G内存的电脑，超过500M，就应该考虑将数据存到硬盘上，然后利用SOAR包进行调用。通常可如下调用 library(SOAR) Store(&quot;some_data&quot;) 这会有如下动作： 在工作目录下创建一个子目录.R_Cache。这个目录是隐藏的，可以通过在RStudio右下角Plane中的Files标签中通过勾选显示隐藏而看到。 对象some_data以.Rdata的形式存储在该子目录中； 对象some_data在全局环境中被删掉； 此时，在该工作目录下，可以像调用全局环境中的变量一样调用some_data。同时还可以用Remove来去掉该变量，用Ls()来查看路径中有哪些变量。 5.3 RStudio-server管理 rstudio-server start #启动 rstudio-server stop #停止 rstudio-server restart #重启 查看运行中R进程 rstudio-server active-sessions 指定PID，停止运行中的R进程 rstudio-server suspend-session &lt;pid&gt; 停止所有运行中的R进程 rstudio-server suspend-all 强制停止运行中的R进程，优先级最高，立刻执行 rstudio-server force-suspend-session &lt;pid&gt; rstudio-server force-suspend-all RStudio Server临时下线，不允许web访问，并给用户友好提示 rstudio-server offline RStudio Server临时上线 rstudio-server online 5.4 平行计算 5.4.1 循环中的平行运算 平行计算中，光使用foreach包是不够的，还需要注册一个平行背景注册，否则foreach包在运算完以后会返回警告： # Warning message: # # executing %dopar% sequentially: no parallel backend registered 平行计算一般的工作流如下： library(doParallel) cl &lt;- parallel::makeCluster(2) doParallel::registerDoParallel(cl) foreach(i=1:3, .pacakages = &#39;tidyverse&#39;) %dopar% sqrt(i) parallel::stopCluster(cl) 要注意，平行计算中，在foreach后的语句中，相当于在每个进程中，重启了一个新环境。因此，如果你要用到foreach外面的变量，则需要把变量、包等都传进去。同时，这些变量如果是向量或者list则不需要特别地指定迭代变量是哪个，程序会自动将它们处理成迭代变量。如果这些变量的长度不一，则迭代时以最少长度的变量为准。一个简单的例子(VARrf::IRFrf_gen)如下： # 传进去了5个变量,nhist, itevar,pmax,s, shockvar，这些变量的长度都是一样的。 picdata &lt;- foreach::foreach(i = 1:nhist,itevar = itevar, pmax = pmax_para,s = s, shockvar = shockvar, .packages = &#39;tidyverse&#39;) %dopar% { devtools::load_all() IRFrf(data = itevar, pmax = pmax, s = s, shockvar = shockvar,histime = i) } 5.4.2 apply族的平行版本 library(parallel) # 检查系统有几个核，然后全部利用 cl &lt;- makeCluster(detectCores()) # Windows并行时，每个进程中是没有变量的，所以要把函数或变量导入到每个进程中去 clusterExport(cl,c(&#39;fun1&#39;,&#39;var1&#39;)) # 或者要把某个包导入到进程中去 clusterEvalQ(cl,{ library(randomForestSRC) library(tidyverse) }) %&gt;% invisible() # 并行运算 parLapply(cl, c(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;), FUN) stopCluster(cl) 5.5 类和方法 5.5.1 S3类 # 查看属于一个泛型函数的所有方法： methods(&#39;mean&#39;) ## [1] mean.Date mean.default mean.difftime mean.POSIXct mean.POSIXlt ## [6] mean.quosure* ## see &#39;?methods&#39; for accessing help and source code # 反过来，查看一个类，都有何关联的泛型函数 methods(class = &#39;ts&#39;) ## [1] [ [&lt;- aggregate as.data.frame cbind ## [6] coerce cycle diff diffinv initialize ## [11] kernapply lines Math Math2 monthplot ## [16] na.omit Ops plot print show ## [21] slotsFromS3 t time window window&lt;- ## see &#39;?methods&#39; for accessing help and source code 创建一个类，很多时候只需在最后返回一个这样的，就可以了， class(foo) &lt;- &#39;myclass&#39; 然后为这个类创建一个泛型函数，只需要两步： # 创建一个类 a &lt;- list() class(a) &lt;- &#39;a&#39; # 第一步：增加一个新的泛型函数。记住，没有搭配该泛型函数的方法，泛型函数是没有用的。 f &lt;- function(x) UseMethod(&#39;f&#39;) # 第二步，为此泛型函数添加方法。关键在于命名规则，属于该泛型函数的方法一定具有类似f.a格式的命名。 # f是泛型函数, a是类,它们用点连起来。 f.a &lt;- function(x) &#39;class a&#39; mean.a &lt;- function(x) &#39;a&#39; # 为已有的泛型函数增加方法 5.6 打印到文件 sink函数：在代码开始前加一行：sink(“output.txt”)，就会自动把结果全部输出到工作文件夹下的output.txt文本文档。这时在R控制台的输出窗口中是看不到输出结果的。代码结束时用sink()切换回来。 示例： sink(&quot;a.txt&quot;) x&lt;-rnorm(100,0,1) mean(x) sink() cat函数：cat('abc','OK!',file = 'a.txt',sep = '\\n',append = T) stargazer函数： stargazer(fit1, fit2, title = &quot;results&quot;, align = F, type = &quot;text&quot;, no.space = TRUE, out = &quot;fit.html&quot;) 5.7 apply函数族 lapply(vector,fun)，可以将函数作用于向量vector的每一个元素上，然后返回一个list。 sapply(vector,fun)的好处在于不是返回一个list，而是返回一个向量或者矩阵。如果fun返回的是一个元素，那么sapply就返回一个向量，如果fun返回的是一个向量，则sapply按列将结果拼接成一个矩阵。 sapply(1:10, function(i) i^2) ## [1] 1 4 9 16 25 36 49 64 81 100 sapply(1:10, function(i) c(i^2,i)) ## [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] ## [1,] 1 4 9 16 25 36 49 64 81 100 ## [2,] 1 2 3 4 5 6 7 8 9 10 apply是我用得最熟的，它是将函数应用到矩阵或数组的行或列上。 mapply是lapply或sapply的多元版本，即它可以同时输入多个向量，如 mapply(function(x,y,z) x*y + y*z + x*z, x = c(1,2,3),y = c(1,2,3), z = c(-1,-2,-3)) ## [1] -1 -4 -9 5.8 Linux中的R 很多时候，对服务器我们没有权限，因此我们只能下载包的源码，然后安装。工作流如下： - 在自己有权限的目录下新建一个目录，比如/data/stage/chenpu/RLib作为包的安装目录，命令为 mkdir /data/stage/chenpu/RLib 将包的源码下载下来，然后命令行安装 R CMD INSTALL /.../mypackage.tar.gz --library=/data/stage/chenpu/RLib 在R跑程序，加载的时候，要注意lib.loc参数， library(zoo, lib.loc = &#39;/data/stage/chenpu/RLib&#39;) 或者修改启动文件.Rprofile，这就不会每次启动R都要重新设置了。 5.8.1 如何修改.Rprofile？ 进入R以后， R.home() # 确定R安装在了哪里 file.edit(file.path(&#39;~&#39;,&#39;.Rprofile&#39;)) # 编辑Rprofile # 此时进入vi界面， 在插入模式下，键入 .libPaths(&#39;/data/stage/chenpu/RLib&#39;) # 再按Esc退出插入模式进入命令行模式，输入`:wq`保存退出。 5.8.2 Ubuntu下安装最新的R 在/etc/apt/sources.list文件中增加软件的镜像源，deb https://cloud.r-project.org/bin/linux/ubuntu bionic-cran40/，也就是增加这样一行。注意后面这个bionic-cran40，它对应着Ubuntu系统下R4.0版本。 更新源： sudo apt-get update 更新的时候往往会报错，说是没有公钥。此时用这个命令增加公钥： sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 6AF0E1940624A220 注意，此处6AF0E1940624A220是你更新源时报错提示的key。 3. 安装： sudo apt-get install r-base 5.9 如何完美复制项目的结果 在写一个项目时，往往对应着当时你调用的各种R包的版本。一年以后，许多包已经更新，可能你当时的代码结果已经无法复制。我们需要管理不同版本的R包。 renv包就是干这个的。工作流如下： renv::init()初始化这个项目，会生产对应该项目的包库文件目录。此时安装包，都是在这个私有库下进行，不影响全局的包库。 renv::snapshot()记下此时包的各个版本。 renv::restore()恢复上一个快照时包库的状态。 "],["Eco.html", "6 经济学中的各种专业计算 6.1 一句话Tips 6.2 wwz的贸易增加值分解", " 6 经济学中的各种专业计算 6.1 一句话Tips lpirfs包局部线性投影脉冲响应函数。 library(productivity)计算满奎斯特效率指数，注意日期参数time.var以及个体id.var参数都要是整数。 tfp &lt;- malm(regdata, id.var = &#39;alphabets&#39;,time.var = &#39;yr&#39;, x.vars = c(&#39;wage&#39;,&#39;K&#39;), y.vars = &#39;gdp&#39;) Changes(tfp) # 获得malmquist指数及其成份 产品编码之间的转换包：concordance::concord： It supports concordance between HS (Combined), ISIC Rev. 2,3, and SITC1,2,3,4 product classification codes, as well as BEC, NAICS, and SIC classifications. It also provides code nomenclature / descriptions look-up, Rauch classification look-up (via concordance to SITC2) and trade elasticity look-up (via concordance to SITC2/3 or HS3.ss). ioanalysis提供投入产出表的分析功能 出口增加值分解的包由decompr，这个包有Wang et at. (2013)的分解以及经典的里昂惕夫分解。以及gvc包。 hhi包可以算赫芬达尔指数。 6.2 wwz的贸易增加值分解 分解的主要函数是decomp。但是有一个load_table_vectors函数可以生成一个decompr class，这个类有很多我们想要的东西，如投入产出系数A，里昂惕夫矩阵B以及其他的一些数据。 # load example data data(leather) # create intermediate object (class decompr) decompr_object &lt;- load_tables_vectors(inter, final, countries, industries, out ) 这个类包含了如下内容，我挑一些我确切知道是啥的: B: 里昂惕夫矩阵，即\\((I-A)^{-1}\\) Vc: 增加值系数矩阵 ESR: 总出口，包括中间品出口Eint和最终品Efd出口. L: 单个国家的里昂惕夫逆矩阵 Y: 最终需求。几个国家就几列。 Yd: 自己对自己的需求。也就是在这个矩阵里面，自己对别人的需求都是0。 Ym: 自己对别人的需求。自己对自己的需求都是0。 Bm, Bd: 含义比照Ym, Yd. "],["math.html", "7 数学计算 7.1 一句话Tips 7.2 数值优化", " 7 数学计算 7.1 一句话Tips matlab::meshgrid可能有助于你画3D图。 crossprod(x,y)的意思是\\(x&#39;y\\)，tcrossprod(x,y)的意思是\\(xy&#39;\\)。在OLS估计时还蛮省事。 matlab包模拟了matlab软件中的许多矩阵函数。 克罗内克积使用%x%或者kronecker。 numDeriv里面的hession计算海塞矩阵，它的逆的负数，就是极大似然估计的标准差。里面的grad(fun, par) 计算梯度，也就是一阶导。 Matrix::bdiag(A,A)生成以两个A为对角元素的分块对角矩阵。 Mod计算复数的模，不同于mod用来整除。 caracas: 通过提供对Python SymPy库的访问来实现计算机代数，从而使以符号方式解方程、寻找符号积分、符号和和其他重要量成为可能。 calculus: 针对数值和符号演算提供了C++优化函数，包括符号算术、张量演算、泰勒级数展开、多元埃尔米特多项式等. rootSolve提供了非线性方程(组)的解，以及微分方程的稳态解的形式。 fun &lt;- function (x) cos(2*x)^3 curve(fun, 0, 8) # 先画个图看看解大约在哪里 abline(h = 0, lty = 3) # 把0轴搞出来 uni &lt;- uniroot(fun, c(0, 8))$root # 此时求解 方程组的根求解用multiroot。 7.2 数值优化 在Linux系统下，安装nloptr包，需要先在linux系统中安装nlopt包。 yum install nlopt nlopt-devel 无约束优化。optimx一个优化包，经常用它的optimx函数。但是它是无约束优化，尽管可以包含上下界的约束(盒子约束)。 para &lt;- list(R1 = 0.1, phi1 = 0.8, H1 = 0.3, A1 = 0.8, intcp = 1) %&gt;% as.numeric() # par就是要优化的参数的初值 # fn就是要优化的函数，譬如似然函数，这个函数可以包含多个参数， # 如这里的Y,X,r等。然后那个没写进来的参数就是要优化的参数。 # lnlik &lt;- function(Y = Y, X = X,para = para, r = 1){...} # gr和hess如果必要，可以包含进来。 # lower,upper就是搜寻的上下界。 a &lt;- optimx(par = para, fn = lnlik, Y = Y, X = X, r = 1, lower = c(0.01,0.01,0.01,0.01,-Inf), upper = c(Inf, 0.99,Inf,Inf,Inf),control = list(all.methods = T)) gHgen(par, fn) # 创造得分矩阵，海塞矩阵。 有约束优化。stats::constrOptim和alabama::constrOptim.nl都可进行有约束的优化，后者是对前者的一个强化，不仅在算法上更牛逼，也可以放入非线性约束。后者是用函数如hin(x)&lt;=0的形式来表达约束，需要理解的是，约束函数中的参数一定要与目标函数的参数一致，即便约束函数没有用到目标函数的参数。 # 比如我的目标函数如下 fn &lt;- function (x,a,b){ ... } # 约束函数如下。一定要把a和b写进去，即便函数中未用到它 hin &lt;- function(x, a, b){ ... } # 优化函数如下 constrOptim.nl(par, fn, gr = NULL, hin = NULL, hin.jac = NULL, heq = NULL, heq.jac = NULL, control.outer=list(), control.optim = list(), ...) 一旦得到优化函数，就可以调用numDeriv::hessian(fn, par)来计算海塞矩阵，从而得到标准误之类的。 "],["ML.html", "8 机器学习和微观计量 8.1 一句话Tips 8.2 ROC曲线绘制 8.3 randomForestSRC包使用报告", " 8 机器学习和微观计量 8.1 一句话Tips gfoRmula：一个处理时变处理干扰的R包。 oem包可以执行各类lasso，group lasso等算法。 gsynth广义合成控制包。考虑了交互固定效应。 ArCo: 一个人工反事实的包 ForecastComb一个集成预测的包，包括stacking 方法。 htree基于历史回归树，所以可以用于面板数据的随机森林模型。 tsensembler一个对机器学习多种预测方法进行集成的包，包括随机森林，装袋，支持向量回归等。 knerlab支持向量机和支持向量回归，他的vig写得好。 grf，一个因果树的包。 spikeslab，一个选择变量的贝叶斯方法的包。 orf: 实现Lechner和Okasa（2019）中开发的有序森林估计量，以估计具有有序分类结果的模型（有序选择模型）的条件概率. MatchIt做匹配感觉很好。主要函数是matchit，针对这个函数得到的类，使用summay可以得到匹配前后均值变化，经验分位变化等。这个函数返回的类包含有一个元素match.matrix，里面有被匹配的控制组信息。 8.2 ROC曲线绘制 ROC曲线可以同时展现所有可能阈值出现的两类错误。其横轴为1-特异度(1-specificity)，纵轴为灵敏度（sensitivity）. 调用pROC包即可计算。该包的参数如下： roc(response, predictor, controls, cases, density.controls, density.cases, levels=base::levels(as.factor(response)), percent=FALSE, na.rm=TRUE, direction=c(&quot;auto&quot;, &quot;&lt;&quot;, &quot;&gt;&quot;), algorithm = 5, quiet = TRUE, smooth=FALSE, auc=TRUE, ci=FALSE, plot=FALSE, smooth.method=&quot;binormal&quot;, ci.method=NULL, density=NULL, ...) response: 原始的\\(y\\); pridictor: 估计的\\(\\hat y\\); smooth:是否平滑ROC曲线； percent:是否百分比的形式显示相关信息，如AUC； 8.3 randomForestSRC包使用报告 这个包有几大特征，我就说我用过的几个： 可以因变量多变量建模 rfsrc(cbind(y1, y2, ..., yd) ~ . , my.data, ...) 重要性抽样有置信区间 偏效应计算接口更友好 另外它的返回结果中的err.rate就是袋外误差的MSE。对于多变量建模来说，使用get.mv.error函数可以直接得到该MSE。 "],["otherSF.html", "9 与其他软件的交互 9.1 一句话Tips 9.2 R语言调用Matlab 9.3 R与Python的无缝对接 9.4 与julia的对接 9.5 与C++的对接：Rcpp包", " 9 与其他软件的交互 9.1 一句话Tips stargazer的一个模版调用： stargazer(regression,type = &#39;text&#39;,out = &quot;../PicTab/cmp.html&quot;,no.space = T,report = c(&#39;vcp&#39;)) report意味着报告变量、系数与p值。 officer: 与微软软件互动的一个包 readstata13包读Stata13以后的数据格式。 R语言调用stata 用RStata包可以从R里面调用stata，不过要先用chooseBinStata()先设置stata的安装路径。 也可以在R的启动环境中进行配置。 注意在启动环境中（即Rprofile.site文件中）配置时，应增加如下一行， options(RStata.StataPath = \"\\\"D:\\\\Program Files (x86)\\\\Stata14\\\\StataMP-64\\\"\") R语言读取SPSS（中文字符） # 读英文字符 library(foreign) mydata=read.spss(&quot;data.sav&quot;) # 或者如下 library(Hmisc) data=spss.get(&quot;data.sav&quot;) # 读中文字符 library(memisc) data1 = as.data.set(spss.system.file(&quot;data.sav&quot;)) data = as.data.frame(data1) 9.2 R语言调用Matlab 9.2.1 强大的R.matlab包 一般工作流如下： library(R.matlab) Matlab$startServer() # 启动matlab服务器，可能会较慢 # 创造与matlab交互的客户端对象，并看它的运行状态 matlab &lt;- Matlab() print(matlab) # 打开运行 isOpen &lt;- open(matlab) print(matlab) # matlab中运行脚本 evaluate(matlab, &quot;A = 1+2;&quot;, &quot;B = ones(2, 20);&quot;) # 打印A的值 evaluate(matlab, &quot;A&quot;) # 将matlab中的值传到R中 data &lt;- getVariable(matlab, c(&quot;A&quot;, &quot;B&quot;)) # 将R中的值传到matlab中 ABCD &lt;- matrix(rnorm(10000), ncol = 100) setVariable(matlab, ABCD = ABCD) # 关闭与matlab间的连接 close(matlab) 9.2.2 其他的一些小办法 Matlab里面的三维画图比R要省事很多。这里探讨一下如何从R调用Matlab的一般步骤。 - 安装R.matlab包。使用`writemat(filename,A=A,B=B)`把R里面的数据写进Matlab并保存成`.mat`格式。 - 安装matlabr包。使用`run_matlab_script`命令来执行一个`.m`脚本。或者使用`R.matlab`包里面的`evaluate`来一个一个地执行matlab命令。或者类似于调用stata： library(matlabr) MatlabCode &lt;- &#39; a = 3; b = a+1; &#39; run_matlab_code(MatlabCode) 9.3 R与Python的无缝对接 第一步，首先配置好环境 library(reticulate) use_condaenv(&quot;D:/Anaconda3&quot;) # 安装的python版本环境查看，显示anaconda和numpy的详细信息。放在 # use_condaenv()后，以使配置生效 py_config() py_available()#[1] TRUE #检查您的系统是否安装过Python py_module_available(&quot;pandas&quot;)#检查“pandas”是否安装 第二步，调用有多种方法。我最喜欢这种，就是直接导入python模块，然后用R的风格来调用。此时R里面的美元符号$相当于python里面的“.”符号 ，如， os &lt;- import(&quot;os&quot;) os$getcwd() os$listdir()#您可以使用os包中的listdir（）函数来查看工作目录中的所有文件 numpy &lt;- import(&quot;numpy&quot;) y &lt;- array(1:4, c(2, 2)) y x &lt;- numpy$array(y) x numpy$transpose(x)#将数组进行转置 numpy$linalg$eig(x)#求特征根和特征向量 9.3.1 其他： 当你发现有些包没有，需要安装的时候，可以如下， library(reticulate) # create a new environment conda_create(&quot;r-reticulate&quot;) # install SciPy conda_install(&quot;r-reticulate&quot;, &quot;scipy&quot;) # import SciPy (it will be automatically discovered in &quot;r-reticulate&quot;) scipy &lt;- import(&quot;scipy&quot;) 这是调用时通常需要的代码： library(reticulate) py_config() # 可以查你有几个版本的python # 想使用哪个版本的python use_python(&#39;C:/Users/sheng/AppData/Local/Continuum/anaconda3/python.exe&#39;) # 或者直接在.Rprofile文件中添加一行如：Sys.setenv(RETICULATE_PYTHON = &quot;D:/usr/Anaconda3&quot;) # 以配置路径 # 检查python可不可用 py_available() # 检查模块可不可用 py_module_available(&#39;tushare&#39;) 9.4 与julia的对接 9.4.1 JuliaCall包 感觉此包没有类似reticulate包调用python那么无缝。 在R中执行julia脚本 library(JuliaCall) # 设置存放julia二进制文件的文件夹 julia_setup(JULIA_HOME = &#39;D:/Program Files/Julia-1.4.2/bin&#39;) # 几种主要的调用方式，我把我喜欢的写出来的 julia$command(&quot;a = sqrt(2);&quot;) # 在julia环境中产生了变量a ans &lt;- julia$eval(&quot;a&quot;) # 把变量a的值传给R环境中的ans变量 # 其他的调用方式 julia_command(&quot;a = sqrt(2);&quot;) julia_eval(&quot;a&quot;) #&gt; [1] 1.414214 2 %&gt;J% sqrt #&gt; [1] 1.414214 R与julia互传变量：前面提到的julia_eval可以把julia中的变量传出来，使用julia_assign可以把R中的变量传到julia中去。 julia_assign(&#39;a&#39;,1:5) julia_command(&#39;a&#39;) julia控制台，而且只要你前期julia_setup()了，这个控制台里面就包含了前期运算时的变量 julia_console() # 输入exit 可以退出 # julia&gt; exit 它的函数调用非常吸引人：你甚至可以用R对象作为julia函数的参数 julia_install_package_if_needed(&quot;Optim&quot;) opt &lt;- julia_pkg_import(&quot;Optim&quot;, func_list = c(&quot;optimize&quot;, &quot;BFGS&quot;)) rosenbrock &lt;- function(x) (1.0 - x[1])^2 + 100.0 * (x[2] - x[1]^2)^2 result &lt;- opt$optimize(rosenbrock, rep(0,2), opt$BFGS()) result 9.5 与C++的对接：Rcpp包 9.5.1 Rcpp引入的C++中的标量、向量和矩阵类 在写C++时任何变量通常需要首先声明类型，标量类型包括double, int, String, bool。 向量类型包括NumericVector, IntegerVector, CharacterVector, LogicalVector。这些类型按我的理解，应该是类，对于类就有对应的方法，比如.size()方法就可以计算这个向量的长度。选取向量元素用[]。 此外也有对应矩阵类型(NumericMatrix, IntegerMatrix, CharacterMatrix, LogicalMatrix)。 选取矩阵元素用()而不是[] .nrow(), .ncol()计算矩阵维度 9.5.2 使用sourceCpp函数 单独的C++文件头应包含： #include &lt;Rcpp.h&gt; using namespace Rcpp; // [[Rcpp::export]] /*** R # 这里可以跑R代码，从而可以简单测试上述C++语言 */ 如何从R语言的list类中提取数据？如果mod是从lm返回的list，提取它的残差同时转化为C++的向量，可用as&lt;NumericVector&gt;(mod[\"residuals\"])。 ### C++代码中调用R函数 这给我们提供了极大的方便。调用方式如下： RObject callWithOne(Function f){ return f(1); } 用Function声明R函数； 用RObject表示R函数返回的类型； 现在R中的函数f就可以在C++中用了； "],["DrawTips.html", "10 绘图技巧 10.1 3D绘图", " 10 绘图技巧 10.1 3D绘图 x和y是数值向量，z是矩阵，且z的列数与x的长度一致，行数与y的长度一致。 library(plotly) library(magrittr) x &lt;- seq_len(nrow(volcano)) + 100 y &lt;- seq_len(ncol(volcano)) + 500 plot_ly() %&gt;% add_surface(x = ~x, y = ~y, z = ~volcano) "],["创建包的一些建议.html", "11 创建包的一些建议 11.1 一句话Tips 11.2 使用自己的数据集 11.3 测试 11.4 泛型函数 11.5 其他", " 11 创建包的一些建议 11.1 一句话Tips 要输出函数，记得在注释中书写@export 从RStudio中创建一个包项目 不再使用library()或者require()，因为这会改变搜索路径。而是在控制台输入usethis::use_package('magrittr',type = 'Imports',min_version = NULL)执行一下。该命令在DESCRIPTION文件中添加如下语句： Imports: ggplot2, tidyverse 这个语句的作用只是保证了在安装包时，这些包必须被安装。因此，你在写函数时，要调用这个包，需要使用pdg::fun()。或者在函数文档中添加注释如@import magrittr（不建议该操作，可能会改变全局环境，该操作实际上修改了NAMESPACE文件）。我经常使用这个函数#' @importFrom magrittr '%&gt;%'。 - 执行devtools::document()以产生函数的说明文档。 - 执行devtools::load_all()将sourceR/目录下所有文件 - check()在本地整个地检验包是否可行，而devtools::check_win_*()族函数将其提交至CRAN服务器进行检查，并在10-20分钟后通过邮件返回你一个结果。 11.2 使用自己的数据集 如果你想使用一个脚本来创造一个数据集，然后这个数据集在你发布的包中使用。那么首先执行命令usethis::use_data_raw('MySet')，它有三个功能： 生成data-raw子目录。 在data-raw目录下生成脚本MySet.R，该脚本最后一行是usethis::use_data(MySet),该语句是将MySet.R脚本中创造的数据，以rda的格式保存到data目录中。 在.Rbuildignore中添加语句使得在建立包时，data-raw里面的东西不会被包含进将来要发布的包中。 建立数据文档和建立函数文档一样，你也只需要在R/下面建立一个R文件，该文件只包含一个写着数据名字的字符串，然后前面是描述。一般数据集文档包含两个标签@format和@source。 非R语言格式的数据文件放到inst/下面。 如果你有一个数据集，只是在你的函数内部调用，你可以用use_data(myvar,overwrite = T,internal = T)命令，它在R/下生成数据文件sysdata.rdata，它包含了变量myvar。然后你在函数中直接调用该变量。 11.3 测试 要提交包到CRAN必须有测试。执行devtools::testhat()做了三件事： - 创建tests/testthat目录； - 在Description的Suggests域增加testthat; - 创建一个文件tests/testthat.R。这个文件不要动。通常是在tests/testthat/目录下面建立类似这样的测试文件(文件名总以test开始)， context(&quot;string length&quot;) text_that(&#39;&#39;,{ expect_equal(.,.) expect_equal(.,.) }) 当你完成这些工作以后，你可以简单的输入devtools::test()来一次性检查测试是否成功。 11.4 泛型函数 当你拓展一个泛型函数的时候，需要注意： 函数末端返回NextMethod()。 t.data.frame &lt;- function(x) { x &lt;- as.matrix(x) NextMethod(&quot;t&quot;) } 方法要包含原始泛型的所有参数，顺序也要一致。 缺省设置也要和原始泛型一致。 11.5 其他 可以使用devtools::use_readme_rmd()来创建README.Rmd并将其添加到.Rbuildignore，这将可以在readme中生成R代码。 使用devtools::use_travis()建立一个基本的.travis.yml配置文件，以便以后每次推送都自动检查是否符合包的规范。当然，这需要在traivis网站中打开这个项目的开关。 包中调用ggplot2::aes()时，通常会报错没有显式绑定全局变量，因此最好使用ggplot2::aes_string()。 @example /data/stage/chenpu/a.R是把单独文件中的例子添加到函数文档中，而@examples则是直接添加。 "],["其他-2.html", "12 其他", " 12 其他 geosphere::distm根据经纬度算距离。 stats19一个下载英国交通事故记录的数据库。 pacman包管理包，如p_load()。 vitae: 提供多个模板和功能以简化简历的制作和维护. DiagrammeR：R语言画流程图，网络图，太棒了。教程网址：http://rich-iannone.github.io/DiagrammeR/ progress包可以显示进度条。更具体的例子见收藏或者帮助。 library(progress) pb &lt;- progress_bar$new(total = 500) # 循环中的次数 for (i in 1:500){ pb$tick() } swirl可以编写交互式教程。 RSelenium包终于在201901月出来了。 "],["references.html", "References", " References "]]
